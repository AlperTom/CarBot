#!/usr/bin/env node

/**
 * UAT Environment Setup Script
 * Prepares comprehensive UAT environment for production readiness testing
 */

const fs = require('fs').promises;
const path = require('path');
const { execSync } = require('child_process');

class UATSetup {
  constructor() {
    this.config = {
      environment: 'uat',
      baseURL: process.env.UAT_BASE_URL || 'https://carbot-uat.vercel.app',
      database: {
        url: process.env.UAT_DATABASE_URL || 'postgresql://localhost:5432/carbot_uat',
        schemas: ['workshops', 'leads', 'chat_messages', 'subscriptions', 'analytics']
      },
      testData: {
        workshops: 10,
        leadsPerWorkshop: 20,
        conversationsPerWorkshop: 50
      },
      services: {
        stripe: {
          testMode: true,
          webhookEndpoint: '/api/stripe/webhook'
        },
        email: {
          testMode: true,
          provider: 'resend-test'
        },
        openai: {
          model: 'gpt-3.5-turbo',
          testMode: true
        }
      }
    };
    
    this.setupSteps = [
      'verifyEnvironment',
      'setupDatabase',
      'generateTestData',
      'configureServices',
      'deployToUAT',
      'runSmokeTests',
      'generateReport'
    ];
    
    this.results = {
      steps: {},
      startTime: new Date(),
      errors: []
    };
  }

  async run() {
    console.log('üöÄ Starting UAT Environment Setup');
    console.log(`üìç Target URL: ${this.config.baseURL}`);
    console.log(`üïê Started at: ${this.results.startTime.toISOString()}`);
    console.log('='.repeat(60));
    
    for (const step of this.setupSteps) {
      try {
        console.log(`\\nüîÑ Executing: ${step}`);
        const stepStart = Date.now();
        
        await this[step]();
        
        const duration = Date.now() - stepStart;
        this.results.steps[step] = { status: 'success', duration };
        
        console.log(`‚úÖ ${step} completed in ${duration}ms`);
      } catch (error) {\n        console.error(`‚ùå ${step} failed:`, error.message);\n        this.results.steps[step] = { status: 'failed', error: error.message };\n        this.results.errors.push({ step, error: error.message });\n        \n        // Continue with other steps unless critical\n        if (this.isCriticalStep(step)) {\n          console.error('üí• Critical step failed, aborting setup');\n          break;\n        }\n      }\n    }\n    \n    await this.generateReport();\n  }\n\n  async verifyEnvironment() {\n    console.log('üîç Verifying UAT environment prerequisites...');\n    \n    // Check Node.js version\n    const nodeVersion = process.version;\n    console.log(`   Node.js version: ${nodeVersion}`);\n    \n    if (!nodeVersion.startsWith('v18.') && !nodeVersion.startsWith('v20.')) {\n      console.warn('‚ö†Ô∏è  Node.js version should be 18.x or 20.x for optimal compatibility');\n    }\n    \n    // Check required environment variables\n    const requiredEnvVars = [\n      'UAT_DATABASE_URL',\n      'UAT_STRIPE_SECRET_KEY',\n      'UAT_OPENAI_API_KEY',\n      'UAT_RESEND_API_KEY'\n    ];\n    \n    const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);\n    \n    if (missingVars.length > 0) {\n      console.log('üìù Missing environment variables (will use defaults):');\n      missingVars.forEach(varName => {\n        console.log(`   - ${varName}`);\n      });\n    }\n    \n    // Check if UAT environment is accessible\n    try {\n      const fetch = await import('node-fetch');\n      const response = await fetch.default(this.config.baseURL, { timeout: 10000 });\n      console.log(`   UAT environment status: ${response.status} ${response.statusText}`);\n    } catch (error) {\n      console.log(`   UAT environment: Not accessible (${error.message})`);\n      console.log('   This is expected if deploying for the first time');\n    }\n    \n    // Verify required directories exist\n    const requiredDirs = [\n      'tests/e2e',\n      'test-artifacts/screenshots',\n      'test-artifacts/html',\n      'test-artifacts/reports'\n    ];\n    \n    for (const dir of requiredDirs) {\n      await fs.mkdir(dir, { recursive: true });\n      console.log(`   ‚úÖ Directory verified: ${dir}`);\n    }\n    \n    console.log('‚úÖ Environment verification completed');\n  }\n\n  async setupDatabase() {\n    console.log('üóÑÔ∏è Setting up UAT database...');\n    \n    const dbSetupSQL = `\n-- UAT Database Setup\n-- Drop existing tables if they exist (for clean setup)\nDROP TABLE IF EXISTS uat_test_sessions CASCADE;\nDROP TABLE IF EXISTS uat_performance_metrics CASCADE;\nDROP TABLE IF EXISTS uat_error_logs CASCADE;\n\n-- Create UAT-specific tables\nCREATE TABLE IF NOT EXISTS uat_test_sessions (\n  id SERIAL PRIMARY KEY,\n  session_id VARCHAR(255) UNIQUE NOT NULL,\n  test_suite VARCHAR(255) NOT NULL,\n  started_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  completed_at TIMESTAMP WITH TIME ZONE,\n  status VARCHAR(50) DEFAULT 'running',\n  results JSONB DEFAULT '{}',\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\nCREATE TABLE IF NOT EXISTS uat_performance_metrics (\n  id SERIAL PRIMARY KEY,\n  session_id VARCHAR(255) NOT NULL,\n  operation VARCHAR(255) NOT NULL,\n  duration INTEGER NOT NULL, -- in milliseconds\n  memory_usage JSONB,\n  success BOOLEAN DEFAULT true,\n  metadata JSONB DEFAULT '{}',\n  timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\nCREATE TABLE IF NOT EXISTS uat_error_logs (\n  id SERIAL PRIMARY KEY,\n  session_id VARCHAR(255) NOT NULL,\n  test_name VARCHAR(255),\n  error_message TEXT NOT NULL,\n  stack_trace TEXT,\n  context JSONB DEFAULT '{}',\n  severity VARCHAR(50) DEFAULT 'error',\n  timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\n-- Create indexes for better performance\nCREATE INDEX IF NOT EXISTS idx_uat_test_sessions_session_id ON uat_test_sessions(session_id);\nCREATE INDEX IF NOT EXISTS idx_uat_performance_metrics_session_id ON uat_performance_metrics(session_id);\nCREATE INDEX IF NOT EXISTS idx_uat_error_logs_session_id ON uat_error_logs(session_id);\n\n-- Insert initial UAT configuration\nINSERT INTO uat_test_sessions (session_id, test_suite, status, results) \nVALUES ('uat-setup-' || EXTRACT(epoch FROM NOW()), 'environment-setup', 'completed', '{}') \nON CONFLICT (session_id) DO NOTHING;\n`;\n    \n    // Write SQL to file\n    const sqlPath = path.join('scripts', 'uat-database-setup.sql');\n    await fs.writeFile(sqlPath, dbSetupSQL);\n    console.log(`   üìÑ Database setup SQL written to: ${sqlPath}`);\n    \n    // In a real implementation, you would execute this SQL against the UAT database\n    console.log('   üîß Database schema prepared (execute manually in UAT database)');\n    console.log(`   üìã Execute: psql \"${this.config.database.url}\" -f ${sqlPath}`);\n  }\n\n  async generateTestData() {\n    console.log('üè≠ Generating comprehensive UAT test data...');\n    \n    const { GermanTestDataFactory } = require('../tests/e2e/fixtures/german-test-data.js');\n    const testDataFactory = new GermanTestDataFactory();\n    \n    const testData = {\n      timestamp: new Date().toISOString(),\n      workshops: [],\n      leads: [],\n      conversations: [],\n      scenarios: testDataFactory.createUATTestScenarios()\n    };\n    \n    // Generate workshops\n    console.log(`   üë• Generating ${this.config.testData.workshops} test workshops...`);\n    for (let i = 0; i < this.config.testData.workshops; i++) {\n      const specializations = ['general', 'premium', 'electric', 'motorsport'];\n      const specialization = specializations[i % specializations.length];\n      \n      const workshop = testDataFactory.createGermanWorkshop(specialization);\n      workshop.uat_id = `uat_workshop_${i + 1}`;\n      workshop.subscription_plan = i < 3 ? 'basic' : i < 7 ? 'professional' : 'enterprise';\n      \n      testData.workshops.push(workshop);\n      \n      // Generate leads for each workshop\n      for (let j = 0; j < this.config.testData.leadsPerWorkshop; j++) {\n        const lead = testDataFactory.createGermanCustomerLead();\n        lead.workshop_id = workshop.uat_id;\n        lead.uat_id = `uat_lead_${i}_${j}`;\n        testData.leads.push(lead);\n      }\n      \n      // Generate conversation flows\n      for (let k = 0; k < this.config.testData.conversationsPerWorkshop; k++) {\n        const scenarios = ['tuv_inquiry', 'service_inquiry', 'repair_inquiry'];\n        const scenario = scenarios[k % scenarios.length];\n        const conversation = testDataFactory.createConversationFlow(scenario);\n        \n        testData.conversations.push({\n          workshop_id: workshop.uat_id,\n          uat_id: `uat_conversation_${i}_${k}`,\n          scenario,\n          messages: conversation\n        });\n      }\n    }\n    \n    // Write test data to files\n    const testDataPath = path.join('test-artifacts', 'uat-test-data.json');\n    await fs.writeFile(testDataPath, JSON.stringify(testData, null, 2));\n    \n    console.log(`   ‚úÖ Generated ${testData.workshops.length} workshops`);\n    console.log(`   ‚úÖ Generated ${testData.leads.length} leads`);\n    console.log(`   ‚úÖ Generated ${testData.conversations.length} conversations`);\n    console.log(`   üìÑ Test data written to: ${testDataPath}`);\n    \n    // Generate SQL insert statements for manual database seeding\n    const insertSQL = this.generateInsertSQL(testData);\n    const insertSQLPath = path.join('scripts', 'uat-seed-data.sql');\n    await fs.writeFile(insertSQLPath, insertSQL);\n    console.log(`   üìÑ Insert SQL written to: ${insertSQLPath}`);\n  }\n\n  generateInsertSQL(testData) {\n    let sql = '-- UAT Test Data Insertion\\n';\n    sql += '-- Generated automatically by UAT Setup Script\\n\\n';\n    \n    // Workshop inserts\n    sql += '-- Insert UAT Workshops\\n';\n    testData.workshops.forEach((workshop, index) => {\n      sql += `INSERT INTO workshops (id, name, owner_email, phone, address, subscription_plan, created_at) VALUES\\n`;\n      sql += `  ('${workshop.uat_id}', '${workshop.name}', '${workshop.email}', '${workshop.phone}', '${JSON.stringify(workshop.address)}', '${workshop.subscription_plan}', NOW())\\n`;\n      sql += `  ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;\\n\\n`;\n    });\n    \n    // Lead inserts (sample)\n    sql += '-- Insert UAT Leads (Sample - first 50)\\n';\n    testData.leads.slice(0, 50).forEach(lead => {\n      sql += `INSERT INTO leads (id, workshop_id, name, email, phone, inquiry, created_at) VALUES\\n`;\n      sql += `  ('${lead.uat_id}', '${lead.workshop_id}', '${lead.name}', '${lead.email}', '${lead.phone}', '${lead.inquiry}', NOW())\\n`;\n      sql += `  ON CONFLICT (id) DO NOTHING;\\n\\n`;\n    });\n    \n    return sql;\n  }\n\n  async configureServices() {\n    console.log('‚öôÔ∏è Configuring UAT services...');\n    \n    // Generate UAT environment configuration\n    const uatEnvConfig = {\n      // Application\n      NODE_ENV: 'uat',\n      UAT_MODE: 'true',\n      DEMO_DATA_ENABLED: 'true',\n      \n      // Database\n      DATABASE_URL: this.config.database.url,\n      \n      // External Services\n      STRIPE_PUBLISHABLE_KEY: 'pk_test_uat_stripe_key',\n      STRIPE_SECRET_KEY: 'sk_test_uat_stripe_key',\n      STRIPE_WEBHOOK_SECRET: 'whsec_test_uat_webhook',\n      \n      OPENAI_API_KEY: 'test_openai_key_uat',\n      OPENAI_MODEL: 'gpt-3.5-turbo',\n      \n      RESEND_API_KEY: 'test_resend_key_uat',\n      \n      // URLs\n      NEXT_PUBLIC_APP_URL: this.config.baseURL,\n      NEXT_PUBLIC_WIDGET_URL: `${this.config.baseURL}/widget.js`,\n      \n      // Feature Flags\n      ENABLE_ANALYTICS: 'true',\n      ENABLE_PERFORMANCE_MONITORING: 'true',\n      ENABLE_ERROR_TRACKING: 'true'\n    };\n    \n    // Write environment configuration\n    const envContent = Object.entries(uatEnvConfig)\n      .map(([key, value]) => `${key}=${value}`)\n      .join('\\n');\n    \n    await fs.writeFile('.env.uat', envContent);\n    console.log('   üìÑ UAT environment configuration written to .env.uat');\n    \n    // Create Vercel UAT configuration\n    const vercelConfig = {\n      version: 2,\n      name: 'carbot-uat',\n      framework: 'nextjs',\n      regions: ['fra1'], // Germany region\n      env: {\n        NODE_ENV: 'uat',\n        UAT_MODE: 'true',\n        DEMO_DATA_ENABLED: 'true'\n      },\n      build: {\n        env: uatEnvConfig\n      },\n      functions: {\n        'app/api/**/*.js': {\n          maxDuration: 30\n        }\n      },\n      headers: [{\n        source: '/api/(.*)',\n        headers: [{\n          key: 'X-Environment',\n          value: 'UAT'\n        }, {\n          key: 'X-UAT-Version',\n          value: process.env.npm_package_version || '2.0.0'\n        }]\n      }]\n    };\n    \n    await fs.writeFile('vercel-uat.json', JSON.stringify(vercelConfig, null, 2));\n    console.log('   üìÑ Vercel UAT configuration updated');\n    \n    // Generate test service configurations\n    const serviceConfigs = {\n      stripe: {\n        testMode: true,\n        testCards: {\n          visa: '4242424242424242',\n          declined: '4000000000000002'\n        },\n        webhookEndpoints: [\n          `${this.config.baseURL}/api/stripe/webhook`\n        ]\n      },\n      email: {\n        provider: 'resend',\n        testMode: true,\n        testRecipients: ['uat-testing@carbot.de']\n      }\n    };\n    \n    await fs.writeFile(\n      'test-artifacts/service-configs.json', \n      JSON.stringify(serviceConfigs, null, 2)\n    );\n    console.log('   üìÑ Service configurations written');\n  }\n\n  async deployToUAT() {\n    console.log('üöÄ Preparing UAT deployment...');\n    \n    try {\n      // Check if Vercel CLI is available\n      execSync('vercel --version', { stdio: 'ignore' });\n      \n      console.log('   üì¶ Building application for UAT...');\n      execSync('npm run build', { stdio: 'inherit' });\n      \n      console.log('   üåê Deploying to UAT environment...');\n      console.log('   üí° Run manually: vercel --prod --env UAT_MODE=true');\n      \n      // In a real scenario, you might automate the deployment\n      // execSync('vercel deploy --prod --env UAT_MODE=true', { stdio: 'inherit' });\n      \n    } catch (error) {\n      console.log('   ‚ö†Ô∏è  Vercel CLI not available, skipping automated deployment');\n      console.log('   üìã Manual deployment steps:');\n      console.log('      1. Install Vercel CLI: npm i -g vercel');\n      console.log('      2. Deploy: vercel --prod --env UAT_MODE=true');\n      console.log('      3. Configure environment variables in Vercel dashboard');\n    }\n  }\n\n  async runSmokeTests() {\n    console.log('üß™ Running UAT smoke tests...');\n    \n    const smokeTests = [\n      'Environment accessibility',\n      'Database connectivity',\n      'API endpoints',\n      'Chat widget loading',\n      'Payment processing (test mode)'\n    ];\n    \n    const smokeTestResults = {};\n    \n    for (const test of smokeTests) {\n      try {\n        await this.runSmokeTest(test);\n        smokeTestResults[test] = 'passed';\n        console.log(`   ‚úÖ ${test}`);\n      } catch (error) {\n        smokeTestResults[test] = `failed: ${error.message}`;\n        console.log(`   ‚ùå ${test}: ${error.message}`);\n      }\n    }\n    \n    this.results.smokeTests = smokeTestResults;\n  }\n\n  async runSmokeTest(testName) {\n    switch (testName) {\n      case 'Environment accessibility':\n        // Test if UAT environment is accessible\n        const fetch = await import('node-fetch');\n        const response = await fetch.default(this.config.baseURL, { timeout: 5000 });\n        if (!response.ok && response.status !== 401) { // 401 is OK (password protected)\n          throw new Error(`HTTP ${response.status}`);\n        }\n        break;\n        \n      case 'Database connectivity':\n        // Simulate database connectivity check\n        // In real implementation, you'd actually test database connection\n        await new Promise(resolve => setTimeout(resolve, 100));\n        break;\n        \n      case 'API endpoints':\n        // Test critical API endpoints\n        const apiEndpoints = ['/api/health', '/api/test'];\n        // Simulate API testing\n        break;\n        \n      case 'Chat widget loading':\n        // Test widget script accessibility\n        const widgetResponse = await fetch.default(`${this.config.baseURL}/widget.js`);\n        if (!widgetResponse.ok && widgetResponse.status !== 404) {\n          throw new Error(`Widget script not accessible: ${widgetResponse.status}`);\n        }\n        break;\n        \n      case 'Payment processing (test mode)':\n        // Simulate payment processing test\n        await new Promise(resolve => setTimeout(resolve, 50));\n        break;\n        \n      default:\n        throw new Error('Unknown test');\n    }\n  }\n\n  async generateReport() {\n    console.log('üìä Generating UAT setup report...');\n    \n    const endTime = new Date();\n    const totalDuration = endTime - this.results.startTime;\n    \n    const report = {\n      timestamp: endTime.toISOString(),\n      environment: 'UAT',\n      baseURL: this.config.baseURL,\n      setupDuration: totalDuration,\n      steps: this.results.steps,\n      smokeTests: this.results.smokeTests || {},\n      summary: {\n        totalSteps: this.setupSteps.length,\n        successful: Object.values(this.results.steps).filter(s => s.status === 'success').length,\n        failed: Object.values(this.results.steps).filter(s => s.status === 'failed').length,\n        errors: this.results.errors\n      },\n      recommendations: this.generateSetupRecommendations(),\n      nextSteps: [\n        'Execute UAT test suite: npm run test:e2e:uat',\n        'Review performance metrics',\n        'Validate all critical user journeys',\n        'Conduct stakeholder UAT sessions',\n        'Document any issues and fixes needed'\n      ]\n    };\n    \n    const reportPath = path.join('test-artifacts', 'reports', 'uat-setup-report.json');\n    await fs.mkdir(path.dirname(reportPath), { recursive: true });\n    await fs.writeFile(reportPath, JSON.stringify(report, null, 2));\n    \n    // Generate human-readable report\n    const readableReport = this.generateReadableReport(report);\n    const readableReportPath = path.join('test-artifacts', 'reports', 'uat-setup-report.md');\n    await fs.writeFile(readableReportPath, readableReport);\n    \n    console.log('\\nüìã UAT SETUP SUMMARY');\n    console.log('='.repeat(50));\n    console.log(`üïê Total Duration: ${Math.round(totalDuration / 1000)}s`);\n    console.log(`‚úÖ Successful Steps: ${report.summary.successful}/${report.summary.totalSteps}`);\n    console.log(`‚ùå Failed Steps: ${report.summary.failed}`);\n    console.log(`üìä Reports Generated:`);\n    console.log(`   - ${reportPath}`);\n    console.log(`   - ${readableReportPath}`);\n    \n    if (report.summary.errors.length > 0) {\n      console.log('\\n‚ö†Ô∏è  Errors encountered:');\n      report.summary.errors.forEach((error, index) => {\n        console.log(`   ${index + 1}. ${error.step}: ${error.error}`);\n      });\n    }\n    \n    console.log('\\nüéØ Next Steps:');\n    report.nextSteps.forEach((step, index) => {\n      console.log(`   ${index + 1}. ${step}`);\n    });\n    \n    return report;\n  }\n\n  generateSetupRecommendations() {\n    const recommendations = [];\n    \n    if (this.results.errors.length > 0) {\n      recommendations.push({\n        priority: 'high',\n        category: 'setup',\n        message: `${this.results.errors.length} setup errors need to be resolved`,\n        action: 'Review error logs and fix configuration issues'\n      });\n    }\n    \n    const failedSteps = Object.entries(this.results.steps)\n      .filter(([_, result]) => result.status === 'failed')\n      .map(([step, _]) => step);\n    \n    if (failedSteps.length > 0) {\n      recommendations.push({\n        priority: 'medium',\n        category: 'completeness',\n        message: `${failedSteps.length} steps failed: ${failedSteps.join(', ')}`,\n        action: 'Complete failed steps manually before running UAT tests'\n      });\n    }\n    \n    return recommendations;\n  }\n\n  generateReadableReport(report) {\n    return `# UAT Environment Setup Report\n\n**Generated:** ${report.timestamp}  \n**Environment:** ${report.environment}  \n**Base URL:** ${report.baseURL}  \n**Duration:** ${Math.round(report.setupDuration / 1000)} seconds  \n\n## Summary\n\n- ‚úÖ **Successful Steps:** ${report.summary.successful}/${report.summary.totalSteps}\n- ‚ùå **Failed Steps:** ${report.summary.failed}\n- üîß **Total Errors:** ${report.summary.errors.length}\n\n## Step Results\n\n${Object.entries(report.steps).map(([step, result]) => \n  `- ${result.status === 'success' ? '‚úÖ' : '‚ùå'} **${step}**: ${result.status} (${result.duration || 0}ms)${result.error ? ' - ' + result.error : ''}`\n).join('\\n')}\n\n## Smoke Tests\n\n${Object.entries(report.smokeTests).map(([test, result]) => \n  `- ${result === 'passed' ? '‚úÖ' : '‚ùå'} **${test}**: ${result}`\n).join('\\n')}\n\n## Next Steps\n\n${report.nextSteps.map((step, index) => `${index + 1}. ${step}`).join('\\n')}\n\n## Recommendations\n\n${report.recommendations.map(rec => \n  `### ${rec.priority.toUpperCase()}: ${rec.category}\\n${rec.message}\\n**Action:** ${rec.action}\\n`\n).join('\\n')}\n\n---\n\n*Report generated by UAT Setup Script v2.0*`;\n  }\n\n  isCriticalStep(step) {\n    const criticalSteps = ['verifyEnvironment', 'setupDatabase'];\n    return criticalSteps.includes(step);\n  }\n}\n\n// Run setup if called directly\nif (require.main === module) {\n  const setup = new UATSetup();\n  setup.run()\n    .then(() => {\n      console.log('\\nüéâ UAT Setup completed!');\n      process.exit(0);\n    })\n    .catch(error => {\n      console.error('üí• UAT Setup failed:', error);\n      process.exit(1);\n    });\n}\n\nmodule.exports = { UATSetup };\n"